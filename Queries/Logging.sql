SELECT * FROM 
(
SELECT 'CURRENT' AS STATUS, NULL AS LOGSLNO, V.*,  V.USERID, V.ENTRYDATE, UA.FULLNAME FROM USERS.USERACCOUNTS UA INNER JOIN ELECTIONS.TRAININGVENUES V ON UA.USERID = V.USERID
WHERE V.VENUECODE IN (SELECT VENUECODE FROM LOGS.TRAININGVENUES)
UNION ALL 
SELECT 'HISTORY' AS STATUS, V.*, UA.FULLNAME FROM USERS.USERACCOUNTS UA INNER JOIN LOGS.TRAININGVENUES V ON UA.USERID = V.USERID
)S
ORDER BY VENUECODE, LOGSLNO NULLS FIRST;




DROP TABLE LOGS.TRAININGVENUES ;

CREATE TABLE LOGS.TRAININGVENUES AS SELECT USERID AS LOGSLNO, TBL.*, USERID AS UPDATEDBY, ENTRYDATE AS ACTIONDATE FROM ELECTIONS.TRAININGVENUES TBL WHERE 1 = 2 ;
CREATE OR REPLACE FUNCTION logs.logtrainingvenues()
  RETURNS trigger AS
$BODY$
BEGIN

	IF TG_OP = 'UPDATE' THEN
		INSERT INTO logs.trainingvenues  VALUES (
		CASE WHEN (SELECT MAX(LOGSLNO) + 1 FROM LOGS.TRAININGVENUES) IS NULL THEN 1
			ELSE (SELECT MAX(LOGSLNO) + 1 FROM LOGS.TRAININGVENUES)
		END,
		OLD.OFFICECODE, OLD.SLNO, OLD.VENUECODE, OLD.VENUEDESCRIPTION, OLD.USERID, OLD.ENTRYDATE, NEW.USERID, CURRENT_TIMESTAMP  );
	ELSEIF TG_OP = 'DELETE' THEN
		INSERT INTO logs.trainingvenues  VALUES (
		CASE WHEN (SELECT MAX(LOGSLNO) + 1 FROM LOGS.TRAININGVENUES) IS NULL THEN 1
			ELSE (SELECT MAX(LOGSLNO) + 1 FROM LOGS.TRAININGVENUES)
		END,
		OLD.OFFICECODE, OLD.SLNO, OLD.VENUECODE, OLD.VENUEDESCRIPTION, OLD.USERID, OLD.ENTRYDATE, OLD.USERID, CURRENT_TIMESTAMP  );
	END IF;	

        RETURN OLD;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION logs.logtrainingvenues()
  OWNER TO elections;

CREATE TRIGGER logTrainingVenues AFTER DELETE  OR UPDATE   ON ELECTIONS.TRAININGVENUES FOR EACH ROW EXECUTE PROCEDURE logs.logTRAININGVENUES();



----------------------


DROP TABLE LOGS.OFFICES ;

CREATE TABLE LOGS.OFFICES AS SELECT USERID AS LOGSLNO, TBL.*, USERID AS UPDATEDBY, ENTRYDATE AS ACTIONDATE FROM MASTERS.OFFICES TBL WHERE 1 = 2 ;
CREATE OR REPLACE FUNCTION logs.logOFFICES()
  RETURNS trigger AS
$BODY$
BEGIN

	IF TG_OP = 'UPDATE' THEN
		INSERT INTO logs.OFFICES  VALUES (
		CASE WHEN (SELECT MAX(LOGSLNO) + 1 FROM LOGS.OFFICES) IS NULL THEN 1
		ELSE (SELECT MAX(LOGSLNO) + 1 FROM LOGS.OFFICES)
		END,
		old.districtcode,old.officeslno,old.officecode,old.officename,old.header1,old.header2,old.header3,old.officeaddress,
		old.officecategorycode,old.signatoryname,old.signatorydesignation,old.iselectionoffice,
		old.referenceofficecode,old.enabled,old.signature,old.officeabbreviation,old.userid,old.entrydate,
		NEW.USERID, CURRENT_TIMESTAMP  
		);
	ELSEIF TG_OP = 'DELETE' THEN
		INSERT INTO logs.OFFICES  VALUES (
		CASE WHEN (SELECT MAX(LOGSLNO) + 1 FROM LOGS.OFFICES) IS NULL THEN 1
		ELSE (SELECT MAX(LOGSLNO) + 1 FROM LOGS.OFFICES)
		END,
		old.districtcode,old.officeslno,old.officecode,old.officename,old.header1,old.header2,old.header3,old.officeaddress,
		old.officecategorycode,old.signatoryname,old.signatorydesignation,old.iselectionoffice,
		old.referenceofficecode,old.enabled,old.signature,old.officeabbreviation,old.userid,old.entrydate,
		OLD.USERID, CURRENT_TIMESTAMP  
		);
	END IF;

        RETURN OLD;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION logs.logOFFICES()
  OWNER TO elections;


DROP TRIGGER IF EXISTS logofficestrigger ON MASTERS.OFFICES;
CREATE TRIGGER logOFFICES AFTER DELETE  OR UPDATE   ON MASTERS.OFFICES FOR EACH ROW EXECUTE PROCEDURE logs.logOFFICES();


SELECT * FROM 
(
SELECT 'CURRENT' AS STATUS, NULL AS LOGSLNO, V.*,  V.USERID, V.ENTRYDATE, UA.FULLNAME FROM USERS.USERACCOUNTS UA INNER JOIN MASTERS.OFFICES V ON UA.USERID = V.USERID
WHERE V.OFFICECODE IN (SELECT OFFICECODE FROM LOGS.OFFICES)
UNION ALL 
SELECT 'HISTORY' AS STATUS, V.*, UA.FULLNAME FROM USERS.USERACCOUNTS UA INNER JOIN LOGS.OFFICES V ON UA.USERID = V.USERID
)S
ORDER BY OFFICECODE, LOGSLNO NULLS FIRST;



DROP TABLE LOGS.PERSONNEL ;
CREATE TABLE LOGS.PERSONNEL AS SELECT USERID AS LOGSLNO, TBL.*, USERID AS UPDATEDBY, ENTRYDATE AS ACTIONDATE FROM ELECTIONS.PERSONNEL TBL WHERE 1 = 2 ;
CREATE OR REPLACE FUNCTION logs.logPERSONNEL()
  RETURNS trigger AS
$BODY$
BEGIN

	IF TG_OP = 'UPDATE' THEN
		INSERT INTO logs.PERSONNEL  VALUES (
		CASE WHEN (SELECT MAX(LOGSLNO) + 1 FROM LOGS.PERSONNEL) IS NULL THEN 1
		ELSE (SELECT MAX(LOGSLNO) + 1 FROM LOGS.PERSONNEL)
		END,
		old.officecode,	old.slno,	old.employeecode,	old.fullname,	old.gender,	old.dob,	old.designation,	old.basicpay,	old.accountno,	old.ifsccode,	old.isgazettedofficer,	old.epiccardno,	old.acno,	old.partno,	old.mobileno,	old.mobilenosm,	old.isblo,	old.ispwd,	old.pwddetails,	old.isexpectinglactating,	old.isailing,	old.personnelcategorycode,	old.sensitivitycode,	old.photograph,	old.entrydate,	old.userid,
		NEW.USERID, CURRENT_TIMESTAMP  
		);
	ELSEIF TG_OP = 'DELETE' THEN
		INSERT INTO logs.PERSONNEL  VALUES (
		CASE WHEN (SELECT MAX(LOGSLNO) + 1 FROM LOGS.PERSONNEL) IS NULL THEN 1
		ELSE (SELECT MAX(LOGSLNO) + 1 FROM LOGS.PERSONNEL)
		END,
		old.officecode,	old.slno,	old.employeecode,	old.fullname,	old.gender,	old.dob,	old.designation,	old.basicpay,	old.accountno,	old.ifsccode,	old.isgazettedofficer,	old.epiccardno,	old.acno,	old.partno,	old.mobileno,	old.mobilenosm,	old.isblo,	old.ispwd,	old.pwddetails,	old.isexpectinglactating,	old.isailing,	old.personnelcategorycode,	old.sensitivitycode,	old.photograph,	old.entrydate,	old.userid,
		OLD.USERID, CURRENT_TIMESTAMP  
		);
	END IF;

        RETURN OLD;



END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION logs.logPERSONNEL()
  OWNER TO elections;

DROP TRIGGER IF EXISTS logPERSONNELtrigger ON ELECTIONS.PERSONNEL;


SELECT * FROM 
(
SELECT 'CURRENT' AS STATUS, NULL AS LOGSLNO, V.*,  V.USERID, V.ENTRYDATE, UA.FULLNAME FROM USERS.USERACCOUNTS UA INNER JOIN ELECTIONS.PERSONNEL V ON UA.USERID = V.USERID
WHERE V.EMPLOYEECODE IN (SELECT EMPLOYEECODE FROM LOGS.PERSONNEL)
UNION ALL 
SELECT 'HISTORY' AS STATUS, V.*, UA.FULLNAME FROM USERS.USERACCOUNTS UA INNER JOIN LOGS.PERSONNEL V ON UA.USERID = V.USERID
)S
ORDER BY EMPLOYEECODE, LOGSLNO  NULLS LAST


CREATE TRIGGER logPERSONNEL AFTER DELETE  OR UPDATE   ON ELECTIONS.PERSONNEL FOR EACH ROW EXECUTE PROCEDURE logs.logPERSONNEL();